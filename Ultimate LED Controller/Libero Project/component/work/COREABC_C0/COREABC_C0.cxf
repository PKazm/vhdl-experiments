<?xml version="1.0" encoding="UTF-8" standalone="no" ?><Component xmlns="http://actel.com/sweng/afi"><name>COREABC_C0</name><vendor/><library/><version/><fileSets><fileSet fileSetId="OTHER_FILESET"><file fileid="0"><name>./COREABC_C0.sdb</name><userFileType>SDB</userFileType></file><file fileid="1"><name>./COREABC_C0_manifest.txt</name><userFileType>LOG</userFileType></file></fileSet><fileSet fileSetId="COMPONENT_FILESET"><file fileid="2"><name>./COREABC_C0_0/COREABC_C0_COREABC_C0_0_COREABC.cxf</name><userFileType>CXF</userFileType></file><file fileid="3"><name>../../Actel/DirectCore/COREABC/3.7.101/COREABC.cxf</name><userFileType>CXF</userFileType></file></fileSet><fileSet fileSetId="HDL_FILESET"><file fileid="4"><name>./COREABC_C0.vhd</name><fileType>VHDLSource</fileType></file></fileSet></fileSets><hwModel><views><view><fileSetRef>OTHER_FILESET</fileSetRef><fileSetRef>COMPONENT_FILESET</fileSetRef><name>OTHER</name></view><view><fileSetRef>HDL_FILESET</fileSetRef><name>HDL</name></view></views></hwModel><category>SpiritDesign</category><function/><variation>SpiritDesign</variation><vendor>Actel</vendor><version>1.0</version><vendorExtension><type>SpiritDesign</type></vendorExtension><vendorExtension><state value="GENERATED"/></vendorExtension><vendorExtensions><componentRef library="DirectCore" name="COREABC" vendor="Actel" version="3.7.101"/><configuration><configurableElement referenceId="ABCCODE" value="JUMP $MAIN&#xA;// Interrupt Service Routine Here&#xA;    &#xA;    APBREAD 2 Light_Store_Int&#xA;    BITTST 1&#xA;    JUMP IFNOT ZERO $I2C_Process&#xA;    BITTST 0&#xA;    JUMP IFNOT ZERO $Light_Control_Interrupt&#xA;    // interrupt fallthrough&#xA;    AND 0b00000011&#xA;    APBWRT ACC 2 Light_Store_Int&#xA;    RETISR&#xA;&#xA;    $Light_Control_Interrupt&#xA;    // ACC should still be Light_Store_Int&#xA;    AND 0b11111110&#xA;    APBWRT ACC 2 Light_Store_Int&#xA;    // do nothing yet&#xA;    // eventually trigger light sensor read&#xA;    APBWRT DAT8 1 0x00 0b11100000&#xA;    //APBREAD 1 0x6000&#xA;    //APBREAD 1 0x00&#xA;    //APBWRT DAT 0 0x0000 0x40030000&#xA;    //APBREAD 1 0x8048&#xA;    //APBWRT DAT 0 0x0000 0x40000000&#xA;    RETISR&#xA;    &#xA;    $I2C_Process&#xA;    APBREAD 1 0x04&#xA;    CMP DAT8 0x08&#xA;    JUMP IF ZERO $I2C_0x08_Start_Sent&#xA;    CMP DAT8 0x10&#xA;    JUMP IF ZERO $I2C_0x10_Restart_Sent&#xA;    CMP DAT8 0x18&#xA;    JUMP IF ZERO $I2C_0x18_SLA_W_Sent&#xA;    CMP DAT8 0x20&#xA;    // error transmitting SLA+W, send again&#xA;    JUMP IF ZERO $I2C_Continue&#xA;    CMP DAT8 0x28&#xA;    JUMP IF ZERO $I2C_0x28_Data_Sent&#xA;    CMP DAT8 0x30&#xA;    // error transmitting Data, send again&#xA;    JUMP IF ZERO $I2C_Continue&#xA;    //CMP DAT8 0x38&#xA;    // arbitration lost&#xA;    //JUMP IF ZERO $AbandonShip&#xA;    CMP DAT8 0x40&#xA;    JUMP IF ZERO $I2C_0x40_SLA_R_Sent&#xA;    CMP DAT8 0x48&#xA;    // error transmitting SLA+R, send again&#xA;    JUMP IF ZERO $I2C_Continue&#xA;    //CMP DAT8 0x50&#xA;    // ack returned (bad) repeat read will occur&#xA;    CMP DAT8 0x58&#xA;    JUMP IF ZERO $I2C_0x50_Data_Received&#xA;    CMP DAT8 0xE0&#xA;    JUMP IF ZERO $I2C_0xE0_Stop_transmitted&#xA;    &#xA;    &#xA;    $I2C_0x08_Start_Sent&#xA;    // 0x08 will always precede an address+W&#xA;    APBWRT DAT8 1 0x008 (0x29 &lt;&lt; 1) | 0b0&#xA;    JUMP $I2C_Continue&#xA;    &#xA;    $I2C_0x10_Restart_Sent&#xA;    // 0x10 will always precede an address+R (in this design)&#xA;    APBWRT DAT8 1 0x008 (0x29 &lt;&lt; 1) | 0b1&#xA;    JUMP $I2C_Continue&#xA;&#xA;    $I2C_0x18_SLA_W_Sent&#xA;    // 0x18 precedes a register address write&#xA;    //I2C_Reg_Addr is set beforehand when state is set&#xA;    RAMREAD I2C_Reg_Addr&#xA;    APBWRT ACC 1 0x008&#xA;    JUMP $I2C_Continue&#xA;&#xA;    $I2C_0x28_Data_Sent&#xA;    // 0x28 preceeds another data write (reg_value), repeat start (reg_read), or stop&#xA;    //  I2C_State = 0, I2C_Step = 0&#xA;    //      write Reg_Value (only occurs during init in this design)&#xA;    //  I2C_State = 0, I2C_Step = 1&#xA;    //      both Reg_Addr and Reg_Value have been sent, STOP&#xA;    //  I2C_State = [1-3]&#xA;    //      reading each Light Sensor channel, RepeatStart (fallthrough)&#xA;    RAMREAD I2C_State&#xA;    CMP DAT8 0&#xA;    JUMP IFNOT ZERO $I2C_RepeatStart&#xA;    RAMREAD I2C_Step&#xA;    CMP DAT8 1&#xA;    JUMP IF ZERO $I2C_Stop&#xA;    RAMWRT I2C_Step DAT8 1&#xA;    RAMREAD I2C_Reg_Val&#xA;    APBWRT ACC 1 0x008&#xA;    JUMP $I2C_Continue&#xA;&#xA;    $I2C_0x40_SLA_R_Sent&#xA;    // 0x40 precedes receiving the data byte&#xA;    // set ACK response Here&#xA;    // literally just set NACk return, which is done in $I2C_Continue_Read&#xA;    JUMP $I2C_Continue_Read&#xA;&#xA;    $I2C_0x50_Data_Received&#xA;    // 0x50 is the last step, stop or stop/start after this&#xA;    //  read I2C data and send to storage register (custom VHDL)&#xA;    //  increment I2C_State&#xA;    RAMREAD I2C_State&#xA;    CMP DAT8 1&#xA;    JUMP IF ZERO $I2C_CH1_0&#xA;    CMP DAT8 2&#xA;    JUMP IF ZERO $I2C_CH1_1&#xA;    CMP DAT8 3&#xA;    JUMP IF ZERO $I2C_CH0_0&#xA;    // fallthrough: received CH0_1, prep for CH1_0&#xA;        APBREAD 1 0x008&#xA;        APBWRT ACC 2 Light_Store_CH0_1&#xA;        RAMWRT I2C_Reg_Addr 0x88&#xA;        JUMP $I2C_Stop&#xA;    $I2C_CH1_0&#xA;        // received CH1_0 prep for CH1_1&#xA;        APBREAD 1 0x008&#xA;        APBWRT ACC 2 Light_Store_CH1_0&#xA;        RAMWRT I2C_Reg_Addr 0x89&#xA;        JUMP $I2C_StopStart&#xA;    $I2C_CH1_1&#xA;        // received CH1_1 prep for CH0_0&#xA;        APBREAD 1 0x008&#xA;        APBWRT ACC 2 Light_Store_CH1_1&#xA;        RAMWRT I2C_Reg_Addr 0x8A&#xA;        JUMP $I2C_StopStart&#xA;    $I2C_CH0_0&#xA;        // received CH0_0 prep for CH0_1&#xA;        APBREAD 1 0x008&#xA;        APBWRT ACC 2 Light_Store_CH0_0&#xA;        RAMWRT I2C_Reg_Addr 0x8B&#xA;        JUMP $I2C_StopStart&#xA;&#xA;    RETISR&#xA;    //clear interrupt&#xA;    &#xA;    //BEGIN I2C Shared Routines&#xA;&#xA;        $I2C_Continue&#xA;        // Clear Int (and also Start and Stop)&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11000111&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;&#xA;        $I2C_Continue_Read&#xA;        // Clear Int (and Start/Stop) Set return NACK&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11000011&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;        &#xA;        $I2C_RepeatStart&#xA;        // Set state registers&#xA;        RAMWRT I2C_Step DAT8 0&#xA;        // Clear Int, set Start&#xA;        //RAMWRT I2C_Step DAT8 0&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11000111&#xA;        OR DAT8 0b00100000&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;&#xA;        $I2C_StopStart&#xA;        // Set state registers&#xA;        // $I2C_StopStart is only called during the read process, so INC state&#xA;        RAMWRT I2C_Step DAT8 0&#xA;        RAMREAD I2C_State&#xA;        INC&#xA;        RAMWRT I2C_State ACC&#xA;        // Clear Int, set Start and Stop&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11000111&#xA;        OR DAT8 0b00110000&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;        &#xA;        $I2C_Stop&#xA;        // Set state registers&#xA;        RAMWRT I2C_Step DAT8 0&#xA;        RAMWRT I2C_State DAT8 1&#xA;        // Clear Int and set Stop&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11000111&#xA;        OR DAT8 0b00010000&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;&#xA;        $I2C_0xE0_Stop_transmitted&#xA;        APBREAD 1 0x00&#xA;        AND DAT8 0b11110111&#xA;        APBWRT ACC 1 0x00&#xA;        RETISR&#xA;        &#xA;&#xA;        $AbandonShip&#xA;        // Something wrong with transmission&#xA;        RETISR&#xA;&#xA;    //END I2C Shared Routines&#xA;    &#xA;// End Interrupt Service Routine&#xA;// MAIN HERE&#xA;$MAIN&#xA;    &#xA;    // PCLK is 100Mhz&#xA;    &#xA;    // Slot 1 (I2C_C0)&#xA;    // I2C_C0: CTRL      0x00&#xA;    // I2C_C0: STATUS    0x04&#xA;    // I2C_C0: DATA      0x08&#xA;    // I2C_C0: ADDR0     0x0C&#xA;    // I2C_C0: SMBUS     0x10&#xA;    // I2C_C0: ADDR1     0x1C&#xA;&#xA;    // I2C RAM locations&#xA;    // RAM 0x00&#xA;    //  Stores states for overall operation [0 = reg addr, 1 = reg val]&#xA;    // RAM 0x01 Z&#xA;    //  Stores states [Init, CH1_0, CH1_1, CH0_0, CH0_1]&#xA;    // RAM 0x02&#xA;    //  Stores Reg_Addr&#xA;    // RAM 0x03&#xA;    //  Stores Reg_Value&#xA;    DEF I2C_Step 0x00&#xA;    DEF I2C_State 0x01&#xA;    DEF I2C_Reg_Addr 0x02&#xA;    DEF I2C_Reg_Val 0x03&#xA;    DEF Data_Store_Addr 0x04&#xA;&#xA;    // Custom VHDL light sensor registers&#xA;    DEF Light_Store_CTRL    0x00&#xA;    DEF Light_Store_CH0_0   0x01&#xA;    DEF Light_Store_CH0_1   0x02&#xA;    DEF Light_Store_CH1_0   0x03&#xA;    DEF Light_Store_CH1_1   0x04&#xA;    DEF Light_Store_Int     0x05&#xA;&#xA;&#xA;    // Initialize I2C_0 for Light Sensor&#xA;    // PCLK/960 = 0b100; included in enable transfer to save 1 instruction&#xA;    //  This is done when Start is set&#xA;    //APBWRT DAT8 1 0x00 0b10000000&#xA;    // Load RAM slots for Light Sensor Init over I2C&#xA;    RAMWRT I2C_Step DAT8 0&#xA;    RAMWRT I2C_State DAT8 0&#xA;    RAMWRT I2C_Reg_Addr DAT8 0x80&#xA;    RAMWRT I2C_Reg_Val DAT8 0b00011001&#xA;    // Begin Light Sensor init transfer&#xA;    APBWRT DAT8 1 0x00 0b11100000&#xA;&#xA;&#xA;    // SPI_0: CONTROL       0X40001000&#xA;    // SPI_0: TXRXDF_SIZE   0X40001004&#xA;    // SPI_0: STATUS        0X40001008&#xA;    // SPI_0: INT_CLEAR     0X4000100C&#xA;    // SPI_0: RX_DATA       0X40001010&#xA;    // SPI_0: TX_DATA       0X40001014&#xA;    // SPI_0: CLK_GEN       0X40001018&#xA;    // SPI_0: SLAVE_SELECT  0X4000101C&#xA;    // SPI_0: MIS           0X40001020&#xA;    // SPI_0: RIS           0X40001024&#xA;&#xA;    //APBWRT DAT 4 0x1000 0x30&#xA;&#xA;HALT&#xA;    $LOOP&#xA;        //Loop forever waiting for interrupts&#xA;        NOP&#xA;    JUMP $LOOP&#xA;// END MAIN"/><configurableElement referenceId="ACT_CALIBRATIONDATA" value="true"/><configurableElement referenceId="APB_AWIDTH" value="8"/><configurableElement referenceId="APB_DWIDTH" value="8"/><configurableElement referenceId="APB_SDEPTH" value="3"/><configurableElement referenceId="CODEHEXDUMP" value=""/><configurableElement referenceId="CODEHEXDUMP2" value=""/><configurableElement referenceId="DEBUG" value="true"/><configurableElement referenceId="EN_ACM" value="false"/><configurableElement referenceId="EN_ADD" value="true"/><configurableElement referenceId="EN_ALURAM" value="false"/><configurableElement referenceId="EN_AND" value="true"/><configurableElement referenceId="EN_CALL" value="true"/><configurableElement referenceId="EN_DATAM" value="2"/><configurableElement referenceId="EN_INC" value="true"/><configurableElement referenceId="EN_INDIRECT" value="false"/><configurableElement referenceId="EN_INT" value="1"/><configurableElement referenceId="EN_IOREAD" value="true"/><configurableElement referenceId="EN_IOWRT" value="true"/><configurableElement referenceId="EN_MULT" value="0"/><configurableElement referenceId="EN_OR" value="true"/><configurableElement referenceId="EN_PUSH" value="true"/><configurableElement referenceId="EN_RAM" value="true"/><configurableElement referenceId="EN_SHL" value="true"/><configurableElement referenceId="EN_SHR" value="true"/><configurableElement referenceId="EN_XOR" value="true"/><configurableElement referenceId="FAMILY" value="19"/><configurableElement referenceId="HDL_license" value="U"/><configurableElement referenceId="ICWIDTH" value="7"/><configurableElement referenceId="IFWIDTH" value="0"/><configurableElement referenceId="IIWIDTH" value="1"/><configurableElement referenceId="IMEM_APB_ACCESS" value="0"/><configurableElement referenceId="INITWIDTH" value="11"/><configurableElement referenceId="INSMODE" value="0"/><configurableElement referenceId="IOWIDTH" value="1"/><configurableElement referenceId="ISRADDR" value="1"/><configurableElement referenceId="MAX_NVMDWIDTH" value="32"/><configurableElement referenceId="STWIDTH" value="4"/><configurableElement referenceId="TESTBENCH" value="User"/><configurableElement referenceId="TESTMODE" value="0"/><configurableElement referenceId="UNIQ_STRING" value="COREABC_C0_COREABC_C0_0"/><configurableElement referenceId="UNIQ_STRING_LENGTH" value="23"/><configurableElement referenceId="VERILOGCODE" value=""/><configurableElement referenceId="VERILOGVARS" value=""/><configurableElement referenceId="VHDLCODE" value=""/><configurableElement referenceId="VHDLVARS" value=""/><configurableElement referenceId="ZRWIDTH" value="0"/></configuration></vendorExtensions><busInterfaces><busInterface><name>APB3master</name><busType library="AMBA2" name="APB" vendor="AMBA" version="r0p0"/><master/><vendorExtensions><used>true</used></vendorExtensions><signalMap><signal><componentSignalName>PADDR_M</componentSignalName><busSignalName>PADDR</busSignalName></signal><signal><componentSignalName>PSEL_M</componentSignalName><busSignalName>PSELx</busSignalName></signal><signal><componentSignalName>PENABLE_M</componentSignalName><busSignalName>PENABLE</busSignalName></signal><signal><componentSignalName>PWRITE_M</componentSignalName><busSignalName>PWRITE</busSignalName></signal><signal><componentSignalName>PRDATA_M</componentSignalName><busSignalName>PRDATA</busSignalName></signal><signal><componentSignalName>PWDATA_M</componentSignalName><busSignalName>PWDATA</busSignalName></signal><signal><componentSignalName>PREADY_M</componentSignalName><busSignalName>PREADY</busSignalName></signal><signal><componentSignalName>PSLVERR_M</componentSignalName><busSignalName>PSLVERR</busSignalName></signal></signalMap></busInterface></busInterfaces><model><signals><signal><name>NSYSRESET</name><direction>in</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PCLK</name><direction>in</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PRESETN</name><direction>out</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>INTACT</name><direction>out</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>INTREQ</name><direction>in</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PSEL_M</name><direction>out</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PENABLE_M</name><direction>out</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PWRITE_M</name><direction>out</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PREADY_M</name><direction>in</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PSLVERR_M</name><direction>in</direction><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PADDR_M</name><direction>out</direction><left>19</left><right>0</right><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PRDATA_M</name><direction>in</direction><left>7</left><right>0</right><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>PWDATA_M</name><direction>out</direction><left>7</left><right>0</right><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>IO_IN</name><direction>in</direction><left>0</left><right>0</right><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal><signal><name>IO_OUT</name><direction>out</direction><left>0</left><right>0</right><export>false</export><vendorExtensions><pad>false</pad><used>true</used></vendorExtensions></signal></signals></model></Component>